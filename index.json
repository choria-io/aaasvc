[{"content":"Overview This deployment method is suitable to the typical Puppet user who wish to bring a little centralization to their system. It uses certificates from the Puppet CA and you will need to make a number of extra ones.\nThis mode does not completely remove the need for per-user certificates, but, it will help a lot with multi node scenarios and allow you a more easy to manage method of managing RBAC.\nThe system is made up of a few components:\n An Authentication service, called the Authenticator, accessed over HTTP(S), can be run anywhere A Signing service, called the Signer, accessed over Choria RPC, must run in the datacenter where fleets are An Authorization service, called the Authorizer, called by the Signer and ran in the same process Optional audit logging, called Auditors, called by the Authorizers and ran in the same process  Requirements Privileged Certificate You need to obtain from your Certificate Authority a certificate named \u003csomething\u003e.privileged.mcollective, if you are using Puppet you can do that with choria enroll --certname aaasvc.privileged.mcollective. Store the certificate in /etc/aaasvc/ssl/aaasvc.privileged.mcollective.pem and the key in /etc/aaasvc/ssl/aaasvc.privileged.mcollective.key, you also need the CA that signed it stored in /etc/aaasvc/ssl/aaasvc.privileged.mcollective-ca.pem.\nSigning Key-Pair The JWT tokens will be signed using an RSA Key and needs to be generated. It does not need to be signed by a CA.\n$ openssl genrsa -out /etc/aaasvc/jwt-signer.key 2048 $ openssl rsa -in /etc/aaasvc/signer-private.key -outform PEM -pubout -out /etc/aaasvc/jwt-signer.pem Certificate for HTTPS The login service listens on HTTPS and so needs a certificate, key and certificate authority files. Generally these would be from the same Certificate Authority as your fleet nodes - probably Puppet. Store them in /etc/aaasvc/ssl/https.pem, /etc/aaasvc/ssl/https.key, /etc/aaasvc/ssl/https-ca.pem.\nGeneral Service Configuration The AAA Service is configured using a JSON file, here is a basic one showing common parts, the following documentation sections will add to this starter JSON file.\n{  \"logfile\": \"/var/log/aaasvc.log\",  \"loglevel\": \"warn\",  \"site\": \"london\" }    Item Description     logfile A file to log to, this is the standard location which will be covered by the included logrotation configuration   loglevel The logging level, one of debug, info, warn, error or fatal   site A site name to expose in statistics, logs, audits etc, typically a DC name or some unique location identifier    Authenticator Users log into Choria using choria login which communicates with the Authenticator service. We have one Authenticator today called userlist with its own documentation section.\nFor this deployment method the authentication_delegator, service, signed_fleet_management and fleet_management permissions do not apply.\nConfiguration only requires the private key for signing tokens:\n{  \"logfile\": \"/var/log/aaasvc.log\",  \"loglevel\": \"warn\",  \"site\": \"london\",  \"port\": \"443\",  \"tls_certificate\": \"/etc/aaasvc/ssl/https.pem\",  \"tls_key\": \"/etc/aaasvc/ssl/https.key\",  \"tls_ca\": \"/etc/aaasvc/ssl/https-ca.pem\",  \"authenticator\": \"userlist\",  \"userlist_authenticator\": {  \"validity\": \"1h\",  \"signing_key\": \"/etc/aaasvc/signer-private.key\",  \"users\": [],  \"users_file\": \"\"  } } Signer The Signer listens on the Choria RPC network for RPC clients wishing to have their requests signed, signs them and sends the signed request back.\nThe service is scalable horizontally or vertically, you can simply run many instances at the same time, there is no shared state between them or any kind of leader election, it’s all Active-Active and adding more instances adds more capacity.\nChoria Configuration Because the signer connects to Choria it needs a configuration file. Store this in /etc/aaasvc/choria.conf\nplugin.security.provider = file plugin.security.file.certificate = /etc/aaasvc/ssl/aaasvc.privileged.mcollective.pem plugin.security.file.key = /etc/aaasvc/ssl/aaasvc.privileged.mcollective.key plugin.security.file.ca = /etc/aaasvc/ssl/aaasvc.privileged.mcollective-ca.pem plugin.choria.middleware_hosts = choria.example.net:4222 identity = aaa.example.net logfile = /var/log/choria/choria-aaa.example.net.log Signer Configuration The configuration of the signer has a few relevant items, here’s a full configuration for this scenario:\n{  \"choria_config\": \"/etc/aaasvc/choria.conf\",  \"logfile\": \"/var/log/aaasvc.log\",  \"loglevel\": \"warn\",  \"site\": \"london\",  \"signer\": \"basicjwt\",  \"basicjwt_signer\": {  \"signing_certificate\": \"/etc/aaasvc/jwt-signer.pem\",  \"max_validity\":\"2h\",  \"choria_service\": true,  \"allow_bearer_tokens\": true  } }    Property Description     signing_certificate The public key for your Authenticator. Incoming signing requests will have their JWTs verified using this, only ones signed by it will be allowed   max_validity Enforces the maximum validity period on any JWT we accept. The only exception is for tokens with the service claim set to true   choria_service Instructs the Signer to connect to Choria and start a service, otherwise HTTPS must be used to sign requests, strongly recommend to use this method   allow_bearer_tokens This is needed to allow older Choria clients to connect, those did not sign their signing requests    Authorizer There are 2 Authorizers and a given signer server can run only one.\nAction List The Action List Authorizer reads the acls claim from the users JWT and evaluate the request being signed against the list of allowed actions.\n   ACL Description     [\"puppet.status\", \"puppet.enable\"] User can access just these 2 actions and no others   [\"puppet.*\", \"rpcutil.ping\"] User can access all actions under the puppet agent and one under the rpcutil agent   [\"*\"] User can perform all actions on all agents    Configuration is easy, it has no specific configuration.:\n{  \"logfile\": \"/var/log/aaasvc.log\",  \"loglevel\": \"warn\",  \"site\": \"london\",  \"authorizer\": \"actionlist\" } Open Policy Agent Requests can be authorized using Open Policy Agent, it’s a large topic and has it’s own documentation section.\nAuditing Auditors will write a log of every Authorization decision to their configured destination, multiple auditors can be active at a time.\nLogfile This is a simple auditor that just writes a logfile of the actions taken.\n{  \"logfile\": \"/var/log/aaasvc.log\",  \"loglevel\": \"warn\",  \"site\": \"london\",  \"auditors\": [\"logfile\"],  \"logfile_auditor\": {  \"logfile\": \"/var/log/signer_audit.json\"  } } You have to arrange for rotation of this log file, each line will be a JSON line.\nChoria Streams If you want to aggregate audit logs from your regional signers back to the central authentication service this is the auditor to use.\nIt publishes structured messages to a Choria Streams topic that you can use the Choria Stream Replicator to transport these from your regional DC to central for consumption.\nPublished messages will match the io.choria.signer.v1.signature_audit JSON Schema.\n{  \"logfile\": \"/var/log/aaasvc.log\",  \"loglevel\": \"warn\",  \"site\": \"london\",  \"auditors\": [\"jetstream\"],  \"jetstream_auditor\": {  \"cluster_id\": \"test-cluster\",  \"servers\": \"nats://localhost:4222\",  \"topic\": \"audit\"  } } Choria Broker Configuration The broker will verify connections are signed by the Signer, all unsigned or non mTLS connections will be rejected.\nCopy the /etc/aaasvc/jwt-signer.pem to the broker and set this configuration.\nplugin.choria.network.client_signer_cert = /etc/choria/jwt-signer.pem Choria Client Configuration Clients must know to login and requests signing be done, the client.conf settings enable that:\nChoria Network Based Signatures plugin.choria.security.request_signer.token_file = ~/.choria/token plugin.choria.security.request_signer.service = true plugin.login.aaasvc.login.url = https://caaa.example.net/choria/v1/login HTTPS Based Signatures While we strongly suggest signing via the Choria network, HTTP can also be used.\nplugin.choria.security.request_signer.token_file = ~/.choria/token plugin.choria.security.request_signer.url = https://caaa.example.net/choria/v1/sign plugin.login.aaasvc.login.url = https://caaa.ams.devco.net/choria/v1/login Choria Server Configuration There is no specific configuration required on Choria servers when using this method\nFull Sample Configuration Here is a sample configuration with:\n Authenticator on port 433 with external users Signer listening as a service Open Policy Agent Authorizer Logfile auditing  {  \"logfile\": \"/var/log/aaasvc.log\",  \"loglevel\": \"warn\",  \"site\": \"london\",  \"port\": \"443\",  \"tls_certificate\": \"/etc/aaasvc/ssl/https.pem\",  \"tls_key\": \"/etc/aaasvc/ssl/https.key\",  \"tls_ca\": \"/etc/aaasvc/ssl/https-ca.pem\",  \"authenticator\": \"userlist\",  \"authorizer\": \"opa\",  \"auditors\": [\"logfile\"],  \"signer\": \"basicjwt\",  \"basicjwt_signer\": {  \"signing_certificate\": \"/etc/aaasvc/jwt-signer.pem\",  \"max_validity\":\"2h\",  \"choria_service\": true,  \"allow_bearer_tokens\": true  },  \"logfile_auditor\": {  \"logfile\": \"/var/log/signer_audit.json\"  },  \"userlist_authenticator\": {  \"validity\": \"1h\",  \"signing_key\": \"/etc/aaasvc/signer-private.key\",  \"users_file\": \"/etc/aaasvc/users.json\"  } } ","description":"","tags":null,"title":"CA Based","uri":"/configuration/ca/index.html"},{"content":"We distribute an RPM or Docker container for the AAA Service package. Debian is not supported at present.\nYUM Repository For RPMs we publish releases but also nightly builds to our repositories.\nUsers of our Puppet modules will already have these repositories available.\nRelease [choria_release] name=Choria Orchestrator Releases mirrorlist=http://mirrorlists.choria.io/yum/release/el/$releasever/$basearch.txt enabled=True gpgcheck=True repo_gpgcheck=True gpgkey=https://choria.io/RELEASE-GPG-KEY metadata_expire=300 sslcacert=/etc/pki/tls/certs/ca-bundle.crt sslverify=True Nightly Nightly releases are named and versioned aaasvc-0.99.0.20221109-1.el7.x86_64.rpm where the last part of the version is the date.\n[choria_nightly] name=Choria Orchestrator Nightly mirrorlist=http://mirrorlists.choria.io//yum/nightly/el/$releasever/$basearch.txt enabled=True gpgcheck=True repo_gpgcheck=True gpgkey=https://choria.io/NIGHTLY-GPG-KEY metadata_expire=300 sslcacert=/etc/pki/tls/certs/ca-bundle.crt sslverify=True Docker There is a docker container choria-io/aaasvc that has releases only.\n","description":"","tags":null,"title":"Installation","uri":"/installtion/index.html"},{"content":"Configuring the AAA Service requires exact knowledge of your deployment scenarios, we support 2 major approaches:\n Deployment for users with Certificate Authorities and puppet, file, certmanager or pkcs11 Choria Security System (the default) Deployment for users with ED25519 based Organization Issuers and the choria Choria Security System  Most users, today, will fall in the first category.\nGeneral Requirements Authenticator You have to decide on an Authentication system to use. Internally we support just the userlist authenticator that takes a configuration file of users and (encrypted) passwords along with their permissions.\nYou can freely implement your own Authenticator using your own choice of technologies, you will then be responsible for issuing and signing correct Choria format JWT files.\nAuthorizer Each user will need a set of Permissions, and those who get Choria Fleet access via Choria RPC will need a policy attached.\n actionlist - a simple list of Agent and Action pairs to which a user has access at all times opa - an Open Policy Agent based policy language that allows for greater control and expressiveness  It’s worth starting with actionlist while learning the system.\nAuditor As users make Choria requests we can produce a details audit trail of their requests and if those were allowed or not.\nWe support auditing to Choria Streams and to files, you can run multiple auditors at the same time.\nSigner Realistically we have only one request signer that supports Choria JWT tokens. Review the configuration section specific to this component for different scenarios.\nMonitoring We expose metrics to Prometheus, for in-depth monitoring you will need Prometheus or a compatible system.\n","description":"","tags":null,"title":"Configuration","uri":"/configuration/index.html"},{"content":"Overview This deployment method is suitable to users who do not have access to a Certificate Authority. You might be a Puppet user but do not want to use the Puppet CA for multiple purposes or, you deployed using a non-Puppet method and so do not have easy access to a natively supported CA.\nThis mode completely removes the need for per-user x509 certificates, the entire system is controlled by a series of JWT tokens and ed25519 keys. The resulting system is a hybrid system where authentication is handled by AAA Service but Signing is optional and something the AAA Service has full control over.\n Version Hint This applies only to Choria 0.27.0 and newer which is due to ship early 2023\n  The system is made up of a few components:\n An Authentication service, called the Authenticator, accessed over HTTP(S), can be run anywhere A Signing service, called the Signer, accessed over Choria RPC, must run in the datacenter where fleets are An Authorization service, called the Authorizer, called by the Signer and ran in the same process Optional audit logging, called Auditors, called by the Authorizers and ran in the same process  Requirements You must already have a Choria Organization Issuer, essentially a ed25519 key-pair, and you need access to issue new tokens using the Issuer.\nThe Organization Issuer can be made using choria jwt keys or using Hashicorp Vault Transit Secrets Engine.\nIssuer Public Key Obtain your Organization Issuer public key, for the purpose of this documentation we will use 514969e316eb4a7146b8066feb6af5dbc05da0965ec57c9d3a7d3299d5d98fec.\nWe’ll assume the Issuer seed is in choria-issuer.seed.\n Using with Hashicorp Vault If you are using Vault with the Transit Secrets Engine to store your Organization Issuer set the VAULT_ADDR and VAULT_TOKEN environment variables and add --vault to choria jwt commands that need the issuer. Use the key name instead of choria-issuer.seed in the examples.\n  Authenticator JWT You need to have a Choria Client JWT that is signed by the Organization Issuer and is a valid Chain Issuer.\nFirst we create the ed25519 key pair that is unique to the Authenticator:\n$ choria jwt keys /etc/aaasvc/authenticator.seed /etc/aaasvc/authenticator.public Public Key: d19ebddf1e3b41233e776c64c5dfe54861d868101c0ec27105ccead00234abef Now create the JWT, signed by the Issuer:\n$ choria jwt client /etc/aaasvc/authenticator.jwt aaa_chain_delegator choria-issuer.seed \\ --public-key $(cat /etc/aaasvc/authenticator.public) \\ --issuer \\ # It can issue clients --no-fleet-management \\ # It can not access any fleet nodes over RPC --validity 365d # It will expire after 1 year Request Signer JWT You need to have a Choria Client JWT that will be used to sign requests on behalf of other users.\nFirst we create the ed25519 key pair that is unique to the Signer:\n$ choria jwt keys /etc/aaasvc/signer.seed /etc/aaasvc/signer.public Public Key: 7b692d69af281772d7bf98e228451974776b4208608c4a17bb6eebf335ef5142 Now create the JWT, signed by the Issuer:\n$ choria jwt client /etc/aaasvc/signer.jwt aaa_request_signer choria-issuer.seed \\ --public-key $(cat /etc/aaasvc/signer.public) \\ --no-fleet-management \\ # It can not access any fleet nodes over RPC --auth-delegation \\ # It can sign requests on behalf of others --validity 365d # It will expire after 1 year RPC Service JWT You need to have a Choria Server JWT that will be used by the RPC Service that signs requests for other users.\nFirst we create the ed25519 key pair that is unique to the Signer Service:\n$ choria jwt keys /etc/aaasvc/signer-rpc.seed /etc/aaasvc/signer-rpc.public Public Key: d3e0cdf8afc4b827953b3a0c3b01cf80618756d150d1d1e1f70017483a9b4cef Now create the JWT, signed by the Issuer, replace aaa.example.net with an appropriately descriptive name for your environment, like the FQDN hosting the service:\n$ choria jwt server /etc/aaasvc/signer-rpc.jwt aaa.example.net $(cat /etc/aaasvc/signer-rpc.public) choria-issuer.seed --org choria \\ # Must be `choria` for now --collectives choria \\ # Add any other sub collectives you might have --service # It's allowed to host Choria Services on the network General Service Configuration The AAA Service is configured using a JSON file, here is a basic one showing common parts, the following documentation sections will add to this starter JSON file.\n{  \"logfile\": \"/var/log/aaasvc.log\",  \"loglevel\": \"warn\",  \"site\": \"london\" }    Item Description     logfile A file to log to, this is the standard location which will be covered by the included logrotation configuration   loglevel The logging level, one of debug, info, warn, error or fatal   site A site name to expose in statistics, logs, audits etc, typically a DC name or some unique location identifier    Authenticator Users log into Choria using choria login which communicates with the Authenticator service. We have one Authenticator today called userlist with its own documentation section.\nConfiguration only requires the private key for signing tokens:\n{  \"logfile\": \"/var/log/aaasvc.log\",  \"loglevel\": \"warn\",  \"site\": \"london\",  \"port\": \"443\",  \"tls_certificate\": \"/etc/aaasvc/ssl/https.pem\",  \"tls_key\": \"/etc/aaasvc/ssl/https.key\",  \"tls_ca\": \"/etc/aaasvc/ssl/https-ca.pem\",  \"authenticator\": \"userlist\",  \"userlist_authenticator\": {  \"validity\": \"1h\",  \"signing_key\": \"/etc/aaasvc/authenticator.seed\",  \"signing_token\": \"/etc/aaasvc/authenticator.public\",  \"users\": [],  \"users_file\": \"\"  } } Here we set the additional key signing_token.\nSigner The Signer listens on the Choria RPC network for RPC clients wishing to have their requests signed, signs them and sends the signed request back.\nThe service is scalable horizontally or vertically, you can simply run many instances at the same time, there is no shared state between them or any kind of leader election, it’s all Active-Active and adding more instances adds more capacity.\nChoria Configuration Because the signer connects to Choria it needs a configuration file. Store this in /etc/aaasvc/choria.conf\nplugin.security.provider = choria plugin.security.choria.seed_file = /etc/aaasvc/signer-rpc.seed plugin.security.choria.token_file = /etc/aaasvc/signer-rpc.jwt plugin.choria.middleware_hosts = choria.example.net:4222 identity = aaa.example.net logfile = /var/log/choria/choria-aaa.example.net.log Signer Configuration The configuration of the signer has a few relevant items, here’s a full configuration for this scenario:\n{  \"choria_config\": \"/etc/aaasvc/choria.conf\",  \"logfile\": \"/var/log/aaasvc.log\",  \"loglevel\": \"warn\",  \"site\": \"london\",  \"signer\": \"basicjwt\",  \"basicjwt_signer\": {  \"signing_certificate\": \"/etc/aaasvc/authenticator.public\",  \"signing_token\": \"/etc/aaasvc/signer.jwt\",  \"signing_seed\": \"/etc/aaasvc/signer.seed\",  \"max_validity\":\"1h\",  \"choria_service\": true  } }    Property Description     signing_certificate The public key for your Authenticator. Incoming signing requests will have their JWTs verified using this, only ones signed by it will be allowed   signing_token The token used to sign user requests   signing_seed The token used to sign user requests   max_validity Enforces the maximum validity period on any JWT we accept. The only exception is for tokens with the service claim set to true   choria_service Instructs the Signer to connect to Choria and start a service, otherwise HTTPS must be used to sign requests, strongly recommend to use this method    Authorizer There are 2 Authorizers and a given signer server can run only one.\nAction List The Action List Authorizer reads the acls claim from the users JWT and evaluate the request being signed against the list of allowed actions.\n   ACL Description     [\"puppet.status\", \"puppet.enable\"] User can access just these 2 actions and no others   [\"puppet.*\", \"rpcutil.ping\"] User can access all actions under the puppet agent and one under the rpcutil agent   [\"*\"] User can perform all actions on all agents    Configuration is easy, it has no specific configuration.:\n{  \"logfile\": \"/var/log/aaasvc.log\",  \"loglevel\": \"warn\",  \"site\": \"london\",  \"authorizer\": \"actionlist\" } Open Policy Agent Requests can be authorized using Open Policy Agent, it’s a large topic and has it’s own documentation section.\nAuditing Auditors will write a log of every Authorization decision to their configured destination, multiple auditors can be active at a time.\nLogfile This is a simple auditor that just writes a logfile of the actions taken.\n{  \"logfile\": \"/var/log/aaasvc.log\",  \"loglevel\": \"warn\",  \"site\": \"london\",  \"auditors\": [\"logfile\"],  \"logfile_auditor\": {  \"logfile\": \"/var/log/signer_audit.json\"  } } You have to arrange for rotation of this log file, each line will be a JSON line.\nChoria Streams If you want to aggregate audit logs from your regional signers back to the central authentication service this is the auditor to use.\nIt publishes structured messages to a Choria Streams topic that you can use the Choria Stream Replicator to transport these from your regional DC to central for consumption.\nPublished messages will match the io.choria.signer.v1.signature_audit JSON Schema.\n{  \"logfile\": \"/var/log/aaasvc.log\",  \"loglevel\": \"warn\",  \"site\": \"london\",  \"auditors\": [\"jetstream\"],  \"jetstream_auditor\": {  \"cluster_id\": \"test-cluster\",  \"servers\": \"nats://localhost:4222\",  \"topic\": \"audit\"  } } Choria Broker Configuration The Broker will verify connections are signed by anyone the Organization Issuer signed\nplugin.security.issuer.names = choria plugin.security.issuer.choria.public = 514969e316eb4a7146b8066feb6af5dbc05da0965ec57c9d3a7d3299d5d98fec Choria Client Configuration Clients must know to login and requests signing be done, the client.conf settings enable that:\nChoria Network Based Signatures plugin.security.provider = choria plugin.security.choria.token_file = ~/.choria/client.jwt plugin.security.choria.seed_file = ~/.choria/client.key plugin.choria.security.request_signer.service = true plugin.login.aaasvc.login.url = https://caaa.example.net/choria/v1/login Choria Server Configuration The Server will verify requests are signed by anyone the Organization Issuer signed\nplugin.security.issuer.names = choria plugin.security.issuer.choria.public = 514969e316eb4a7146b8066feb6af5dbc05da0965ec57c9d3a7d3299d5d98fec Full Sample Configuration Here is a sample configuration with:\n Authenticator on port 433 with external users Signer listening as a service Open Policy Agent Authorizer Logfile auditing  {  \"logfile\": \"/var/log/aaasvc.log\",  \"loglevel\": \"warn\",  \"site\": \"london\",  \"port\": \"443\",  \"tls_certificate\": \"/etc/aaasvc/ssl/https.pem\",  \"tls_key\": \"/etc/aaasvc/ssl/https.key\",  \"tls_ca\": \"/etc/aaasvc/ssl/https-ca.pem\",  \"authenticator\": \"userlist\",  \"authorizer\": \"opa\",  \"auditors\": [\"logfile\"],  \"signer\": \"basicjwt\",  \"basicjwt_signer\": {  \"signing_certificate\": \"/etc/aaasvc/authenticator.public\",  \"signing_token\": \"/etc/aaasvc/signer.jwt\",  \"signing_seed\": \"/etc/aaasvc/signer.seed\",  \"max_validity\":\"1h\",  \"choria_service\": true  }  \"logfile_auditor\": {  \"logfile\": \"/var/log/signer_audit.json\"  },  \"userlist_authenticator\": {  \"validity\": \"1h\",  \"signing_key\": \"/etc/aaasvc/authenticator.seed\",  \"signing_token\": \"/etc/aaasvc/authenticator.public\",  \"users_file\": \"/etc/aaasvc/users.json\"  } } ","description":"","tags":null,"title":"Org Issuer Based","uri":"/configuration/org-issuer/index.html"},{"content":"The AAA Service keep statistics in the Prometheus format, using this you can see graphs of allow/denies but also get granular statistics for every Agent and Action.\n \nAll the statics have a site label allowing you to easily aggregate a global cluster of AAA Services.\n   Statistic Description     choria_aaa_auditor_errors Total number of audit requests that failed   choria_aaa_authenticator_errors Total number of authentication requests that failed   choria_aaa_authenticator_time Time taken to handle logins   choria_aaa_authorizer_allowed Total number of requests that were allowed   choria_aaa_authorizer_denied Total number of requests that were denied   choria_aaa_authorizer_errors Total number of requests could not be authorized   choria_aaa_signer_errors Total number of requests that could not be signed   choria_aaa_signer_allowed Total number of requests that were allowed by the authorizer   choria_aaa_signer_denied Total number of requests that were denied by the authorizer   choria_aaa_signer_invalid_token Total number of requests that contained invalid tokens   choria_aaa_build_info Build information about the running instance    We have a published Grafana Dashboard for this statistics.\n","description":"","tags":null,"title":"Monitoring","uri":"/monitoring/index.html"},{"content":"Authentication is the act of validating a person is who he claims to be, this is done using a username, token, 2FA or other similar means.\nWhile authentication is provided by this tool, it’s optional you might choose to create JWT tokens using another method of your choosing, the login feature will only be enabled if any authenticator is configured.\nThere is only one authenticator at the moment more might be added again in the future, for now you would set the authenticator key to userlist if you wish to enable it in a specific location.\nUsers are configured either statically in this configuration file or via an external file, the benefit of the external file is that it can be updated without restarting the service.\nPasswords in the files are bcrypt encoded, we provide a utility:\n$ aaasvc crypt test $2a$05$tVM7WO82I.bpdNY6oXxEW.mo388JedJKEdIUqRb06HQ0/wWExyZ1O Basic configuration for the Authenticator can be seen below:\n{  \"logfile\": \"/var/log/aaasvc.log\",  \"loglevel\": \"warn\",  \"site\": \"london\",  \"port\": \"443\",  \"tls_certificate\": \"/etc/aaasvc/ssl/https.pem\",  \"tls_key\": \"/etc/aaasvc/ssl/https.key\",  \"tls_ca\": \"/etc/aaasvc/ssl/https-ca.pem\",  \"authenticator\": \"userlist\",  \"userlist_authenticator\": {  \"validity\": \"1h\",  \"signing_key\": \"/etc/aaasvc/signer-private.key\",  \"users\": [],  \"users_file\": \"\"  } }    Property Description     users Static list of users, see below   users_file Dynamically loaded list of users, see below   validity JWT tokens issued by this service will be valid for this long, 1 hour is a good choice   signing_key A RSA key used for signing tokens    The additional new properties above related to TLS will be the TLS Configuration for the Web Service and the port sets the port that service listens on.\nExternal File We can create an external file with the following content, set the path to this file using users_file. The benefit of this approach is that the file is read on every authentication request hence any chances to it will be immediately live without restarts:\n[  {  \"username\": \"puppetadmin\",  \"password\": \"$2y$05$c4b/0WZ5WJ3nhSZPN9m8keCUPlCYtNOTkqU4fDNEPCUy1C9Pfqn2e\",  \"acls\": [  \"puppet.*\"  ],  \"broker_permissions\": {  \"events_viewer\": true  }  } ] Simply list all your users in this file.\nStatic Configuration Alternatively the users list above can simply be placed in-line in the configuration json file in the users key. Configuration will not be reloaded once started.\nUser Permissions Regardless of the method you pick we have a number of permissions you can set in broker_permissions. The list here is correct for 0.27.0. For an up-to-date list see the Go Documentation for your version of Choria\n   Permission Description     streams_admin Enables full access to Choria Streams for all APIs   streams_user Enables user level access to Choria Streams, no stream admin features   events_viewer Allows viewing lifecycle and auto agent events using API or choria tool event or choria machine watch   election_user Allows using leader elections   system_user Allows accessing the Choria Broker system account without verified TLS   governor Enables access to Governors, cannot make new ones, also requires streams_user permission   org_admin Has access to all subjects and broker system account   fleet_management Enables access to the choria server fleet for RPCs   signed_fleet_management Requires a user to have a valid signature by an AAA Service to interact with the fleet   service Allows a token to have a longer than common lifetime, suitable for services users   authentication_delegator has the right to sign requests on behalf of others    Many of these properties only make sense in the Organization Issuer based deployment scenario.\nUser Fleet Access Policies In Choria you access fleet nodes via the name of the Agent and an Action on the specified Agent, further you can supply Inputs as arguments to the Action.\nAccess policies restricts which agents and actions can be accessed. For full details see later in the Authorizer section.\nAction List When the Authorization is configured using the accesslist Authorizer you set the acls property of the user. An example is [\"puppet.status\", \"puppet.enable\"] to give access to 2 actions. See below for more details.\nOpen Policy Agent When the Authorization is configured using the opa Authorizer you can either load the policy from a file or set it inline. For full examples see the Authorizers section,\nThe per-user policy can be set in the opa_policy as embedded string or in opa_policy_file which will be read from disk and embedded in the resulting JWT.\nChoria Server Authorization Typically, these policies are only evaluated in the AAA Service Signer, you can though also evaluate them in Choria Server before executing your RPC call.\n Version Hint This applies only to Choria 0.27.0 and newer which is due to ship early 2023\n  With this enabled you can create an entirely policy-free server setup as it will require every interaction to have a JWT token with policy embedded.\nrpcauthorization = 1 rpcauthprovider = aaasvc With these 2 lines in your Choria Server it will entirely trust (and require) policies set in these JWTs\n","description":"","tags":null,"title":"Userlist Authenticator","uri":"/configuration/userlist/index.html"},{"content":"The Open Policy Agent based policies allow for very flexible policy to be embedded into the JWT tokens, it allows for policies we have never supported in the past:\n Ensuring filters are used to avoid huge blast radius requests by accident Ensuring specific fact, class or identity filters are used Ensuring a specific collective is used Contents of the JWT claim Checks based on the site the aaasvc is deployed in Checks on every input being sent to the action  This section covers the opa authorizer in detail and will include more detailed examples in time.\nExample Here’s a complex policy:\n# must be in this package package io.choria.aaasvc # it only checks `allow`, its good to default false default allow = false # user can deploy only frontend of myco into production but only in malta allow { input.action == \"deploy\" input.agent == \"myco\" input.data.component == \"frontend\" requires_fact_filter(\"country=mt\") input.collective == \"production\" } # can ask status anywhere in any environment allow { input.action == \"status\" input.agent == \"myco\" } # user can do anything myco related in development allow { input.agent == \"myco\" input.collective == \"development\" } Here we use the requires_fact_filter() to ensure a specific fact filter is used, we have these custom functions:\nFunctions  requires_filter() - ensures that at least one of identity, class, compound of fact filters is not empty requires_fact_filter(\"country=mt\") - ensures the specific fact filter is present in the request requires_class_filter(\"apache\") - ensures the specific class filter is present in the request requires_identity_filter(\"some.node\") - ensures the specific identity filter is present in the request  Request Properties And you’ll have these input items at your disposal:\n agent - the agent being invoked action - the action being invoked data - the contents of the request - all the inputs being sent to the action sender - the sender host collective - the targeted sub collective ttl - the ttl of the request time - the time the request was made site - the site hosting the aaasvcs (from its config) claims - all the JWT claims  Configuration In order to use this you have to set your Signer to use the opa Authorizer and have the opa_policy claim populated in user JWTs\n{  \"logfile\": \"/var/log/aaasvc.log\",  \"loglevel\": \"warn\",  \"site\": \"london\",  \"authorizer\": \"opa\" } ","description":"","tags":null,"title":"OPA Authorizer","uri":"/configuration/opa/index.html"},{"content":"","description":"","tags":null,"title":"Categories","uri":"/categories/index.html"},{"content":"","description":"","tags":null,"title":"Tags","uri":"/tags/index.html"}]